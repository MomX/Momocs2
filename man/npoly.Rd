% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/morpho_npoly.R
\name{npoly}
\alias{npoly}
\title{Natural Polynomial Transform}
\usage{
npoly(x, degree = 5, raw = FALSE, ..., .cols = NULL, .name = "_coe")
}
\arguments{
\item{x}{A matrix (nx2), list of matrices, or tibble with coo columns.}

\item{degree}{Integer. Polynomial degree for the fit. Default is 5.}

\item{raw}{Logical. If \code{TRUE}, returns a list with coefficients and fit details
(only for single matrix). Default is \code{FALSE}.}

\item{...}{Additional arguments (reserved for future use).}

\item{.cols}{Column name(s) to process when \code{x} is a tibble. If \code{NULL},
processes all coo columns automatically.}

\item{.name}{Character. Name suffix for output coefficient columns when \code{x} is
a tibble. Default is \code{"_coe"}. Output columns will be named \code{originalname_coe}.
If a single custom name is provided and multiple columns are processed, an error
is raised.}
}
\value{
\itemize{
\item If \code{x} is a single matrix and \code{raw = FALSE}: returns a named numeric vector
with classes \code{c("npoly", "numeric")} containing degree+1 coefficients (x0, x1, ..., xN)
\item If \code{x} is a single matrix and \code{raw = TRUE}: returns a list with elements
\code{coeff}, \code{degree}, \code{baseline1}, \code{baseline2}, \code{r2}, \code{mod}
\item If \code{x} is a list: returns a list of coefficient vectors (each with class \code{c("npoly", "numeric")})
\item If \code{x} is a tibble: returns the tibble with new list-column(s) of class
\code{c("npoly", "coe", "list")} containing coefficient vectors
}
}
\description{
Compute natural polynomial coefficients from open curve coordinates.
}
\details{
Natural polynomial fitting uses standard power basis polynomials (1, x, x², x³, ...)
to decompose open curves. The method fits a polynomial model to the y-coordinates
as a function of x-coordinates, after baseline normalization.

Unlike orthogonal polynomials, natural polynomials have coefficients that change
when higher degrees are added. However, they are more interpretable and directly
correspond to the polynomial equation.

The curve is automatically baseline-normalized using the first and last points
as landmarks, positioned at (-0.5, 0) and (0.5, 0) respectively.
\subsection{Choosing the polynomial degree}{

The default \code{degree = 5} works well for most open curves. Higher degrees capture
more detail but increase dimensionality and risk overfitting. Use \code{raw = TRUE}
to examine the R² value and assess fit quality.
}
}
\examples{
# Single curve
data(olea)
cur <- olea$VD[[1]]
npoly_coefs <- npoly(cur)
npoly_coefs

# Get raw output with R² and model details
npoly(cur, raw = TRUE)

# With higher degree
npoly(cur, degree = 8)

# List of curves
cur_list <- list(cur, cur * 1.5, cur * 2)
npoly(cur_list)

\dontrun{
# Tibble - processes all coo columns by default
library(dplyr)
olea \%>\%
  npoly(degree = 6)  # Creates VD_coe and VL_coe

# Process specific column only
olea \%>\%
  npoly(.cols = VD)

# Custom name for single column
olea \%>\%
  npoly(.cols = VL, .name = "custom_name")
}

}
\seealso{
\code{\link[=npoly_i]{npoly_i()}} for inverse transform, \code{\link[=opoly]{opoly()}} for orthogonal polynomials,
\code{\link[=dct]{dct()}} for discrete cosine transform.
}
