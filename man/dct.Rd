% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/morpho-dct.R
\name{dct}
\alias{dct}
\title{Discrete Cosine Transform}
\usage{
dct(x, nb_h = 12, raw = FALSE, ..., .cols = NULL, .name = "_coe")
}
\arguments{
\item{x}{A matrix (nx2), list of matrices, or tibble with coo columns.}

\item{nb_h}{Integer. Number of harmonics to compute. Default is 12.}

\item{raw}{Logical. If \code{TRUE}, returns a list with A, B coefficients and
additional components (only for single matrix). Default is \code{FALSE}.}

\item{...}{Additional arguments (reserved for future use).}

\item{.cols}{Column name(s) to process when \code{x} is a tibble. If \code{NULL},
processes all coo columns automatically.}

\item{.name}{Character. Name suffix for output coefficient columns when \code{x} is
a tibble. Default is \code{"_coe"}. Output columns will be named \code{originalname_coe}.
If a single custom name is provided and multiple columns are processed, an error
is raised.}
}
\value{
\itemize{
\item If \code{x} is a single matrix and \code{raw = FALSE}: returns a named numeric vector
with classes \code{c("dct", "numeric")} containing 2*nb_h coefficients (A1-An, B1-Bn)
\item If \code{x} is a single matrix and \code{raw = TRUE}: returns a list with elements
\code{an}, \code{bn}, \code{mod}, \code{arg}
\item If \code{x} is a list: returns a list of coefficient vectors (each with class \code{c("dct", "numeric")})
\item If \code{x} is a tibble: returns the tibble with new list-column(s) of class
\code{c("dct", "coe", "list")} containing coefficient vectors
}
}
\description{
Compute discrete cosine transform coefficients from open curve coordinates.
}
\details{
The Discrete Cosine Transform (DCT) is a Fourier-related method for analyzing
open contours. It decomposes curves into a sum of cosine functions with different
frequencies, capturing shape variation efficiently.

For each harmonic n, two coefficients are computed:
\itemize{
\item An: Real part (related to x-coordinates)
\item Bn: Imaginary part (related to y-coordinates)
}

The method also computes modulus and argument for each harmonic when \code{raw = TRUE}:
\itemize{
\item mod: Amplitude of each harmonic
\item arg: Phase angle of each harmonic
}

The curve is automatically baseline-normalized using the first and last points
as landmarks, positioned at (-0.5, 0) and (0.5, 0) respectively.
\subsection{Choosing the number of harmonics}{

The default \code{nb_h = 12} works well for most open curves. More harmonics capture
finer details but increase dimensionality. Unlike polynomial methods, DCT
harmonics are independent and don't change when adding more.
}
}
\note{
This method can be computationally intensive for large datasets. The
implementation is optimized but may still take time for many shapes.
}
\examples{
# Single curve
data(olea)
cur <- olea$VD[[1]]
dct_coefs <- dct(cur)
dct_coefs

# Get raw output with modulus and argument
dct(cur, raw = TRUE)

# With more harmonics
dct(cur, nb_h = 15)

# List of curves
cur_list <- list(cur, cur * 1.5, cur * 2)
dct(cur_list)

\dontrun{
# Tibble - processes all coo columns by default
library(dplyr)
olea \%>\%
  dct(nb_h = 10)  # Creates VD_coe and VL_coe

# Process specific column only
olea \%>\%
  dct(.cols = VD)

# Custom name for single column
olea \%>\%
  dct(.cols = VL, .name = "dct_coeffs")
}

}
\references{
Dommergues, C. H., Dommergues, J.-L., & Verrecchia, E. P. (2007).
The Discrete Cosine Transform, a Fourier-related Method for Morphometric
Analysis of Open Contours. \emph{Mathematical Geology}, 39(8), 749-763.
}
\seealso{
\code{\link[=dct_i]{dct_i()}} for inverse transform, \code{\link[=opoly]{opoly()}}, \code{\link[=npoly]{npoly()}} for polynomial methods.
}
