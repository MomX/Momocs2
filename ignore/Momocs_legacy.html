<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.553">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Vincent Bonhomme">

<title>Momocs to MomX</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="Momocs_legacy_files/libs/clipboard/clipboard.min.js"></script>
<script src="Momocs_legacy_files/libs/quarto-html/quarto.js"></script>
<script src="Momocs_legacy_files/libs/quarto-html/popper.min.js"></script>
<script src="Momocs_legacy_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="Momocs_legacy_files/libs/quarto-html/anchor.min.js"></script>
<link href="Momocs_legacy_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="Momocs_legacy_files/libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="Momocs_legacy_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="Momocs_legacy_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="Momocs_legacy_files/libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">


</head>

<body class="fullcontent">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Momocs to MomX</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Vincent Bonhomme </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="preamble" class="level1">
<h1>Preamble</h1>
<p>I started writing Momocs in early 2011 while doing my first postdoc at the French Institute of Pondicherry, India, based on Julien Claude’s book Morphometrics with R and using some developments by Sandrine Picq. I was hired by Cédric Gaucherel who was a colleague, a companion, and remains a friend to this day.</p>
<p>By then, I actually knew very little about morphometrics, this was pretty much my first package, I had no developing experience, we were in a pre-tidyverse era, and R overall was far from what it became. But I was really motivated to do some shape analysis myself after 3 years of PhD on Nepenthes with such tempting curves that I could only dream of at the time.</p>
<p>From Julien’s book to a unified package there was some thinking which, of course, proved approximate when looking backwards. From the companion paper published in JSS, cited ~800 times, you can see that my plan was to cover all morphometrics. Once published, I quickly realized that I had to think more about the latent grammar in morphometrics, how landmarks, curves, outlines, and measurements relate to shape quantification and, on the coding side, how to implement this. Hence the early erratic path from S4 to S3 of Momocs.</p>
<p>Around that time, I started doing some consulting and training in R, which allowed me to realize how much of a beginneR I actually was! On the research side, I was hosted at the late CBAE in Montpellier, now part of ISEM, around (and often surrounded by) Jean-Fréderic Terral, Laurent Bouby, Allowen Evin, Sarah Ivorra, Clémence Pagnoux, and Muriel Gros-Balthazard among others. I started the real stuff there, with complex datasets, mostly working on grapevine pips. I then realized that R was quite poor at handling datasets, that Momocs was totally broken in that respect. Then the first bricks of the tidyverse made us all rich.</p>
<p>A couple of years later, after the first studies and quite early adoption of Momocs, notably by archaeobotanists (ourselves aside), I started a new post-doc in Sheffield, UK with a wonderful team around Glynis Jones. There, and then back at ISEM for two other postdocs, I mostly worked on statistical approaches and navigated through the jungle of special cases.</p>
<p>I was dreaming by then that everything morphometrics was a gentle tibble, that ggplot2 could handle morphospace drawing in the background, and that packages could take 20 seconds to R CMD CHECK. I also became a father for the first time and let Momocs become a chubby baby with 20k lines of code, a palimpsest of my journey through coding, life, humour, and morphometrics (possibly not in that order).</p>
<p>The COVID era pushed me to rebuild everything from scratch and the first MomX attempt dates back to early 2020. Since then I’ve been very busy fathering, doing consultancy, rebuilding houses, launching another business of dry-separating toilets—in brief, caught by <em>le tourbillon de la vie</em>. I needed time to think and rewrite all of this and make MomX come true. But time is money.</p>
<p>I finally found a way to fund myself and here we are. In the meantime, the tidyverse and tidymodels became really mature; so did I. And AI became quite good at scraping code, suggesting workarounds, and doing the tedious parts of packaging faster and better. Quite a funny coincidence that two Claude became such an inspiration and companion through Momocs and MomX history.</p>
</section>
<section id="momx-rationale-and-design-principles" class="level1">
<h1>MomX rationale and design principles</h1>
<ul>
<li>The world, and at least myself, needs complete and user-friendly ecosystem for morphometrics</li>
<li>Compartiment key processes into well-defined, interoperable packages that go together well.</li>
<li>Each package should solve a single task, and do it well.</li>
<li>Each package should be easy to understand, improve, debug, update.</li>
</ul>
<p>MomX embraces and owns much to the tidy manifesto. MomX kind of theorise the programming side of morphometrics, or at least itself (yes, infinite loop). Tibbles are the answer. * Make full use of the tidyverse, so that implementation is really lighter now</p>
</section>
<section id="momocs-to-momocs2" class="level1">
<h1>Momocs to Momocs2</h1>
<section id="coogetmeasure" class="level2">
<h2 class="anchored" data-anchor-id="coogetmeasure">coo/get/measure</h2>
<table class="table">
<colgroup>
<col style="width: 15%">
<col style="width: 10%">
<col style="width: 26%">
<col style="width: 32%">
<col style="width: 14%">
</colgroup>
<thead>
<tr class="header">
<th>Function</th>
<th>Input</th>
<th>Output (tibble)</th>
<th>Output (matrix/list)</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>coo_*</code></td>
<td>coo</td>
<td>tibble (coo replaced)</td>
<td>matrix/list</td>
<td>Transform shape</td>
</tr>
<tr class="even">
<td><code>get_*</code></td>
<td>coo</td>
<td>list/vector (extracted)</td>
<td>various</td>
<td>Extract for processing</td>
</tr>
<tr class="odd">
<td><code>measure_*</code></td>
<td>coo</td>
<td>tibble (column added)</td>
<td>scalar(s)</td>
<td>Add measurement column</td>
</tr>
</tbody>
</table>
</section>
<section id="full-list-of-function-changes" class="level2">
<h2 class="anchored" data-anchor-id="full-list-of-function-changes">full list of function changes</h2>
<p>All functions :</p>
<p>Core trasnformations —- coo_center / coo_centre -&gt; coo_centre remove coo_trans -&gt; coo_translate coo_rotate / coo_rotatecenter -&gt; same / coo_rotate_around coo_scale / coo_scalex / coo_scaley -&gt; coo_scale. rm scalex and scaley coo_flipx / coo_flipy -&gt; coo_flip_x/yaxis use axes NEW: coo_flip_x/y allows any x/y intercept (centroid by default). coo_shearx / coo_sheary -&gt; coo_shear_x/y coo_untiltx -&gt; ?</p>
<p>Alignement —- coo_align -&gt; now use centroid as center. NEW: coo_align_minor uses 2nd svd axes (~2nd PC) coo_aligncalliper TODO coo_alignminradius TODO coo_alignxax TODO coo_baseline / coo_bookstein : same name, beter implementation coo_slide -&gt; same behaviour and now guarantee to handle funny values coo_slidedirection -&gt; coo_slide_direction NEW: coo_slide_closest -&gt; can slide to closest of an arbitrary point coo_slidegap -&gt; same</p>
<p>Sampling &amp; smoothing —– coo_sample -&gt; same name but now uses a real approximation along arc length / curvilinear abscissa. Using aprox also allows interpolate. coo_sample_prop -&gt; same coo_samplerr &gt; TODO coo_interpolate -&gt; now included in coo_sample coo_smooth -&gt; same but better implemented coo_smoothcurve -&gt; coo_smooth_fixed</p>
<p>Point manipulation: —– coo_slice -&gt; coo_open # TODO group with coo_open_up, etc. coo_trim -&gt; coo_head coo_trimbottom -&gt; coo_tail coo_trimtop -&gt; coo_head coo_extract -&gt; same coo_rev coo_jitter coo_close coo_unclose coo_force2close</p>
</section>
</section>
<section id="return-scalars" class="level1">
<h1>RETURN SCALARS</h1>
<p>Area &amp; perimeter: measure_area # coo_area measure_perim # coo_perim measure_perimcum # was coo_perimcum (cumulative - vector), now splitted in get_perim_cum measure_perimpts # coo_perimpts (per point - vector)</p>
<p>Size &amp; dimensions: measure_centsize # coo_centsize measure_length # coo_length measure_width # coo_width measure_lw # coo_lw (length/width ratio) measure_calliper # coo_calliper</p>
<p>Shape descriptors: measure_circularity # coo_circularity measure_circularityharalick # coo_circularityharalick measure_circularitynorm # coo_circularitynorm measure_convexity # coo_convexity measure_solidity # coo_solidity measure_eccentricityboundingbox # coo_eccentricityboundingbox measure_eccentricityeigen # coo_eccentricityeigen measure_elongation # coo_elongation measure_rectangularity # coo_rectangularity measure_rectilinearity # coo_rectilinearity</p>
<p>Distance and angles: measure_centdist # coo_centdist (vector) measure_dxy # coo_dxy (vector) measure_diffrange # coo_diffrange measure_angle_edges # coo_angle_edges (vector) measure_angle_tangent # coo_angle_tangent (vector) measure_tangle # coo_tangle (vector)</p>
<p>Ranges and positions: measure_range # coo_range (2 values) measure_centpos # coo_centpos measure_nb # coo_nb (number of points)</p>
<p>Truss and scalars measure_truss # coo_truss measure_scalars # coo_scalars</p>
<p>Plotting functions coo_plot -&gt; pile coo_draw -&gt; draw_* coo_draw_rads -&gt; removed coo_arrows -&gt; TODO ? viz ? coo_lolli -&gt; viz coo_oscillo -&gt; viz coo_ruban -&gt; viz coo_tac -&gt; get ? # TODO coo_listpanel -&gt; mosaic</p>
<p>stack -&gt; pile (to avoid conflct with existing stack) panel -&gt; mosaic</p>
<p>MISC (selon Claude)</p>
<p>coo_boundingbox # bbox corners coordinates? -&gt; get bounding box ? coo_chull # convex hull coordinates # TODO coo_chull_onion # -&gt; get_chull # TODO coo_ldk # removed. See Momacs. coo_range_enlarge # removed</p>
<p>coo_check # validation# TODO coo_is_closed # logical check # TODO but not a coo coo_template # same name # TODO (and add to mosaic !!!) coo_template_relatively # TODO</p>
<p>coo_up / coo_down / coo_left / coo_right # TODO coo_likely_clockwise / coo_likely_anticlockwise # logical check</p>
<p>coo_intersect_angle coo_intersect_direction coo_intersect_segment</p>
</section>
<section id="momacs" class="level1">
<h1>Momacs</h1>
</section>
<section id="the-coming-teenage-of-momx" class="level1">
<h1>The coming teenage of MomX</h1>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>